# Capítulo VI: Product Implementation, Validation & Deployment

---

## 6.1. Software Configuration Management

En este punto del informe se describe las decisiones y los principios que ayudarán al equipo a garantizar la coherencia durante el desarrollo de la solución.

### 6.1.1. Software Development Environment Configuration

En este apartado se proporcionan los enlaces a las aplicaciones y productos de
software creados durante el ciclo del proyecto utilizando los programas correspondientes.

Con ese fin, se organizará en las siguientes secciones:
1. [ ] Project Management
2. [ ] Requirements Management
3. [ ] Product UX/UI Design
4. [ ] Software Development
5. [ ] Software Testing
6. [ ] Software Documentation

Asimismo, se clasificarán los elementos de estas secciones como rutas de referencia
(para software basado en modelos Saas) o rutas de descarga (para productos que se
ejecuten en las computadoras de los miembros del equipo) para cada uno de los productos
de software.

**Project Management**

Esta disciplina se fundamenta en la administración de proyectos y busca principalmente
la mejora de procesos y su entorno con el propósito de lograr los resultados 
esperados.

* Durante el ciclo digital del proyecto, se llevará a cabo la implementación de un 
producto de software basado en el modelo SaaS, el cual funcionará a través de un 
de una aplicación móvil con backend alojada en la nube.

**Requirements Management:**

Este proceso se enfoca en asegurar que una organización documente, verifique y satisfaga las
necesidades y expectativas de sus clientes, así como las de las partes interesadas internas
o externas.


* **Jira Software:** Esta es una plataforma que facilita la gestión de historias de usuario,
  organizándolas en epopeyas y evaluando su importancia en el programa según su prioridad y puntos
  de historia. Se utiliza debido a su capacidad para permitir que cada miembro del equipo tenga una
  vista en tiempo real de los avances en cada proyecto, contribuyendo con diferentes secciones o
  ajustando el flujo del proyecto según sea necesario.

**Product UX/UI Design**

Esta herramienta facilita la creación digital de modelos que se integran en la vida del consumidor.
En este caso, estamos desarrollando un modelo de sitio web compatible tanto con computadoras como
con dispositivos móviles.

Para lograrlo, utilizamos varias herramientas de diseño y colaboración, que incluyen:

1. **Uxpressia:** Uxpressia es una plataforma en línea especializada en el mapeo de la trayectoria del
   cliente. Nos ayuda a crear mapas de impacto y perfiles de usuario, como User Personas, Empathy Maps
   y Journey Maps. Puedes encontrar más información sobre Uxpressia en este [enlace](https://uxpressia.com/).

2. **MIRO:** MIRO es una pizarra digital colaborativa en línea que se adapta a diversas actividades
   colaborativas, como investigación, ideación, creación de lluvias de ideas y mapas mentales. Es una
   herramienta versátil que facilita el trabajo en equipo. Descubre más sobre MIRO en su
   [sitio web](https://miro.com/es/).

3. **Figma:** Figma es una herramienta de prototipado web y un editor de gráficos vectoriales. A
   diferencia de otras herramientas, Figma se ejecuta en línea, lo que permite crear modelos que
   funcionan tanto en navegadores web como en navegadores móviles. Puedes explorar
   Figma en [este enlace](https://www.figma.com/es-es/).

4. **Draw.io:** Esta es una aplicación de diagramación en línea que permite a los usuarios colaborar y
   trabajar juntos en tiempo real para crear una variedad de diseños, incluidos diagramas UML, mapas
   mentales, prototipos de software y otros tipos de diagramas. Puedes conocer más acerca de Lucid Chart
   en [este enlace](https://app.diagrams.net/).

5. **Overflow:** Overflow es una herramienta de diagramación que ofrece la posibilidad de colaborar en
   tiempo real. Utilizamos esta herramienta para crear diagramas de Userflows. Si deseas obtener más
   información sobre Overflow, visita su [sitio web](https://overflow.io/).

Estas herramientas nos ayudan a dar vida a nuestros diseños digitales y a garantizar que nuestros
productos sean accesibles y atractivos en diferentes plataformas.


**Software Development:**

El desarrollo de software es una metodología aplicada en la creación de productos de software. Esta
metodología se utiliza para establecer un proceso que guía el desarrollo del software, y cada uno de
sus pasos describe un enfoque específico para las distintas actividades que ocurren durante el proceso.

Aquí te presentamos algunas herramientas y tecnologías clave que utilizaremos en el proyecto:

1. **GitHub:** GitHub es una plataforma de repositorio comunitario que se utiliza para almacenar y
   gestionar los avances de proyectos realizados por grupos de personas. Puedes acceder al repositorio
   del proyecto en este [enlace](https://github.com/upc-2025-01-MetaSoft-App-Moviles).

2. **Webstorm:** Webstorm es un entorno de desarrollo de JetBrains, una empresa especializada en software,
   orientado al desarrollo web en JavaScript. Esta herramienta proporciona facilidades para probar
   sitios web en navegadores como Google Chrome. En nuestro proyecto, utilizaremos webstorm para
   trabajar con lenguajes como HTML, CSS y JavaScript. Obtén más información sobre WebStorm [aquí](https://www.jetbrains.com/webstorm/).

3. **HTML:** HTML es un lenguaje de marcado que se utiliza en el desarrollo de sitios web para crear
   hipertextos y enlazar a otros documentos. Este lenguaje proporciona herramientas para diseñar
   sitios web y se puede combinar eficazmente con CSS y JavaScript. En nuestro proyecto, utilizaremos
   HTML para implementar la documentación de la página web. Obtén más información sobre la edición de
   archivos HTML en WebStorm [aquí](https://www.jetbrains.com/help/idea/editing-html-files.html).

4. **CSS:** CSS es un lenguaje de diseño destinado al entorno web, que posibilita la mejora de la interfaz
   de usuario previamente diseñada al añadir elementos como colores y tamaños, entre otros. Además,
   es posible crear un estilo en CSS y compartirlo en el sitio web creado en HTML. Este lenguaje será
   empleado en la implementación del diseño de nuestra plataforma web. Puedes obtener más información
   sobre CSS en [enlace](https://www.jetbrains.com/help/idea/style-sheets.html).

5. **JavaScript:** Es un lenguaje de programación que es interpretado por otros programas. Funciona bajo
   el paradigma de programación orientada a objetos (POO), utilizando prototipos en lugar de clases
   para la implementación. Este lenguaje permite crear dinámicas para los usuarios a través de la
   lógica de programación y será utilizado en la creación de las interacciones dinámicas en la plataforma
   web. Puedes encontrar más detalles sobre JavaScript en [enlace](https://www.jetbrains.com/help/idea/style-sheets.html).

6. **Jetpack Compose:** Jetpack Compose es un kit de herramientas moderno para crear interfaces de usuario
   nativas en Android. Permite construir aplicaciones de manera más rápida y sencilla, utilizando un
   enfoque declarativo. En nuestro proyecto, utilizaremos Jetpack Compose para desarrollar la
   aplicación móvil. Puedes obtener más información sobre Jetpack Compose [aquí](https://developer.android.com/jetpack/compose).

7. **Kotlin:** Kotlin es un lenguaje de programación moderno y conciso que se utiliza para desarrollar
   aplicaciones Android. Es interoperable con Java y ofrece características avanzadas que facilitan el
   desarrollo. En nuestro proyecto, utilizaremos Kotlin como el lenguaje principal para la
   implementación de la aplicación móvil. Puedes encontrar más información sobre Kotlin [aquí](https://kotlinlang.org/).

8. **Room:** Room es una biblioteca de persistencia de datos que forma parte de Android Jetpack. Proporciona
   una capa de abstracción sobre SQLite, lo que facilita el acceso a la base de datos y mejora la
   eficiencia del desarrollo. En nuestro proyecto, utilizaremos Room para gestionar la base de datos
   local de la aplicación móvil. Puedes obtener más información sobre Room [aquí](https://developer.android.com/training/data-storage/room).

9. **Retrofit:** Retrofit es una biblioteca de cliente HTTP para Android y Java. Facilita la
   comunicación con servicios web RESTful y simplifica la gestión de solicitudes y respuestas. En
   nuestro proyecto, utilizaremos Retrofit para realizar llamadas a la API y obtener datos del
   servidor. Puedes encontrar más información sobre Retrofit [aquí](https://square.github.io/retrofit/).

Estas herramientas y tecnologías desempeñarán un papel fundamental en la creación exitosa de nuestro
producto de software.

**Software Testing:**

Se trata de la acción de evaluar los elementos y el funcionamiento del software sometido a prueba
mediante procesos de validación y verificación.

**Lenguaje Gherkin:** Este lenguaje, conocido como DSL (Lenguaje Específico de Dominio), está diseñado
específicamente para abordar problemas particulares. Además de poder ser interpretado en código,
permite agregar historias de usuario del programa junto con sus componentes correspondientes, como
Característica, Escenario, Ejemplo, Esquema de Escenario, Dado, Cuando, Entonces y Y.

**Software Documentation**

Se refiere a textos escritos o ilustraciones que acompañan al software de computadora o están
integrados en su código fuente. Esta documentación tiene como objetivo explicar cómo funciona el
software o cómo utilizarlo.

### 6.1.2. Source Code Management

A continuación, se describe la gestión del código fuente, también conocida por las siglas SCM (Source Code Management). Su función principal es rastrear los cambios que realizará el equipo durante el desarrollo de su proyecto en el repositorio de código fuente. Se utilizará como un sistema de control de versiones que lepermitirá realizar un seguimiento de los cambios realizados por miembros o desarrolladores individuales del proyecto. Además, es importante tener en cuenta que usaremos GitHub como nuestro sistema de control de versiones.

1. [ ] URL de la organización: upc-2025-01-MetaSoft-App-Moviles - https://github.com/upc-2025-01-MetaSoft-App-Moviles

2. [ ] URL del repositorio de la Landing Page: ElixirLine -Landing-Page - https://github.com/upc-2025-01-MetaSoft-App-Moviles/ElixirLine-Landing-Page

3. [ ] URL del repositorio de la aplicación móvil: ElixirLine-mobile - 

4. [ ] URL del repositorio del Back-End: ElixirLine-Platform - https://github.com/upc-2025-01-MetaSoft-App-Moviles/ElixirLine-Platform

**GitFlow**

GitFlow es un modelo alternativo para la creación de ramas en Git que se ha convertido en una herramienta esencial para muchos desarrolladores en los últimos años. Este flujo de trabajo de control de versiones, desarrollado y popularizado por Vicent Driessen, desempeña un papel crucial en la gestión de las versiones de un código, facilitando la creación ordenada de nuevas características (Features) y correcciones de problemas urgentes (Hotfixes).

![GitFlow.png](../assets/img/chapter-VI/sprint-1/GitFlow.png)

Como se mencionó previamente, GitFlow opera con ramas o "branches". A continuación, se detallan las ramas que se utilizarán en el flujo de trabajo de nuestro proyecto.

* **Main Branches:**
    * **Main:** Esta es la rama principal desde la cual se ramifican todas las demás. Contendrá la versión más reciente junto con las versiones anteriores creadas por los desarrolladores. Aquí se mantendrá el historial oficial de las versiones publicadas.
    * **Develop:** Esta rama puede ser creada a partir de la rama principal (Main) y contendrá todas las características (Features) estables. A través de esta rama, el equipo podrá integrar las funcionalidades de manera efectiva.

* **Support Branches**
  A diferencia de las ramas principales, estas ramas secundarias tienen una vida útil limitada, ya que se eliminan al fusionarse con sus ramas primarias.
    * **Feature:**
        * Se ramifica de: develop
        * Debe fusionarse de nuevo en: develop
        * Se utilizan para desarrollar las nuevas funciones que se integrarán en la próxima versión. Es importante destacar que esta rama existe únicamente mientras está en proceso de desarrollo. Sin embargo, una vez que el desarrollador haya completado esa función, se fusionará nuevamente con la rama "develop".

* **Convenciones para nombrar los Features:**
    * **Feture Branch:** feature/name
      **Example:**
        1. feature/welcome
        2. feature/about
        3. feture/myfeture
    * **Conventional Commits**
      El commit debe seguir la siguiente estructura:
      **\<type> [optional scope]: \<description>**
      **[optional body]**
      **[optional footer(s)]**
        * **Type:**
          **1\. feat:** Cuando se agrega un nuevo feature.
          **2\. fix:** cuando corriges un error.
          **3\. build:** cuando afectan los componentes de compilación como la herramienta de compilación, las dependencias o la version del proyecto.
          **4\. chore:** modificaciones privadas del código.
          **5\. docs:** commits que afectan solo a la documentación.
          **6\. refractor:** commits que reescriben o reestructura el código, pero no cambia el comportamiento.
          **7\. perf:** commits especiales que mejoran el rendimiento.
          **8\. style:** commits que no afectan el programa. (espacios en blanco, formato, puntos o comas faltantes).
          **9\. test:** commits que agregan pruebas.
        * **Scope**
          Ofrece información contextual adicional. Aunque es opcional, es beneficioso incluirlo para proporcionar a los desarrolladores una descripción más detallada del commit.
          **\<description>**
          Es una parte obligatoria del formato de los commits. Siempre debemos usar lenguaje en modo imperativo y evitar escribir en mayúsculas
          **[optional body]**
          El cuerpo es opcional y, cuando se utiliza, debe explicar la motivación detrás del cambio y contrastarlo con el comportamiento anterior. Es ideal para mencionar identificadores de problemas y sus relaciones.
          **[optional footer(s)]**
          Esta sección es opcional y puede incluir información sobre cambios significativos. Puede hacer referencia al problema por su identificación y, en esta sección, se incluyen los cambios importantes precedidos por "BREAKING CHANGES:" seguido de uno o dos saltos de línea.
          **Ejemplos:**
            1. feat(welcome): add welcome section
            2. build(release): bump version to 1.0.0
            3. style: remove empty line
            4. feat(sign up): add the button to sign up
            5. feat!: email the costumer when product is shipped
            6. feat: remove ticket list endpoint
               refers to JIRA-1337
               BREAKING CHANGES: ticket enpoints no longer supports list all entites.

Como se mencionó previamente, la gestión de nuestro código fuente se llevará a cabo mediante
GitHub. El IDE utilizado en este caso, WebStorm, debe estar vinculado directamente al
repositorio creado por nuestra StartUp. De esta manera, cada commit realizado por
un miembro del equipo se subirá automáticamente y se cargará en el GitHub de la organización. Las instrucciones para completar con éxito este proceso de emparejamiento se detallan a continuación:

* **Activar el controlador de versiones del IDE**
  Dado que utilizaremos GitHub para gestionar nuestro código, la opción que debe estar
  habilitada o seleccionada es aquella que indique que el sistema de control se realizará
  mediante Git. Para hacer esto, siga los siguientes pasos:

    1. Diríjase a la pestaña "VCS" en WebStorm.
    2. Luego, seleccione la opción "Enable Version Control Integration".

![activar-el-controlador-de-versiones-1.png](../assets/img/chapter-VI/sprint-1/activar-el-controlador-de-versiones-1.png)

Ahora se debe seleccionar el sistema de control a través de Git y, por último aceptar los cambios.

![activar-el-controlador-de-versiones-2.png](../assets/img/chapter-VI/sprint-1/activar-el-controlador-de-versiones-2.png)

* **Aregar una cuenta de GitHub, siga estos pasos:**
    1. Diríjase a la sección de configuración en su aplicación.
    2. Dentro de la pestaña 'File', busque y seleccione la opción 'Settings'.
    3. En la configuración, busque la sección de version control.
    4. Agregue su cuenta de GitHub para obtener acceso a los repositorios.


![aregar-una-cuenta-de-GitHub-1.png](../assets/img/chapter-VI/sprint-1/aregar-una-cuenta-de-GitHub-1.png)

![aregar-una-cuenta-de-GitHub-2.png](../assets/img/chapter-VI/sprint-1/aregar-una-cuenta-de-GitHub-2.png)

* **Configurar el nombre de usuario de Git:** Una vez que hayas establecido el sistema de control de versiones que se vinculará con tu IDE, deberás ingresar la cuenta que utilizarás. Para hacerlo, sigue estos pasos:
    1. Realiza un commit en tu proyecto. Durante este proceso, se te solicitará que ingreses tu nombre de usuario de Git.
    2. Después de haberlo añadido, todos los cambios se guardarán en el repositorio especificado en esa plataforma, siempre y cuando des la orden correspondiente.
    3. Para configurar tu nombre de usuario de Git, primero selecciona la opción 'commit' que se encuentra dentro de la pestaña 'Git'.


![configurar-el-nombre-de-usuario-de-Git-1.png](../assets/img/chapter-VI/sprint-1/configurar-el-nombre-de-usuario-de-Git-1.png)


* **Guardar el progreso en GitHub:** Con todo configurado en WebStorm, ahora puedes subir tu código a GitHub sin problemas. Simplemente dirígete a la opción 'GitHub' que se encuentra en la pestaña 'Git' y comparte el proyecto.


![guardar-el-progreso-en-GitHub-1.png](../assets/img/chapter-VI/sprint-1/guardar-el-progreso-en-GitHub-1.png)


![guardar-el-progreso-en-GitHub-2.png](../assets/img/chapter-VI/sprint-1/guardar-el-progreso-en-GitHub-2.png)

* **Configurar la propiedad del repositorio en GitHub:** Ahora, solo necesitas configurar la ubicación del repositorio. El código ya debería estar guardado en GitHub, pero solo estará presente en tu propia cuenta. Para cambiar la propiedad y transferirla a la organización deseada, sigue estos pasos:
    1. Ingresa al repositorio creado en GitHub.
    2. Selecciona la pestaña 'settings'
    3. Dirigite al apartado de 'DangerZone'
    4. Luego da click en 'transfer'
    5. Finalmente elegimos el nuevo lugar para guardar el repositorio.


![configurar-la-propiedad-del-repositorio-en-GitHub-2.png](../assets/img/chapter-VI/sprint-1/configurar-la-propiedad-del-repositorio-en-GitHub-2.png)

![configurar-la-propiedad-del-repositorio-en-GitHub-3.png](../assets/img/chapter-VI/sprint-1/configurar-la-propiedad-del-repositorio-en-GitHub-3.png)

![configurar-la-propiedad-del-repositorio-en-GitHub-4.png](../assets/img/chapter-VI/sprint-1/configurar-la-propiedad-del-repositorio-en-GitHub-4.png)


* **Configurar control remoto en Git:** Por último, dado que el repositorio ahora está bajo la propiedad de la empresa y depende de ella, es necesario acceder al control remoto del código. Para hacerlo, simplemente ingresa al repositorio creado y copia la URL del repositorio.

![configurar-control-remoto-en-Git-1.png](../assets/img/chapter-VI/sprint-1/configurar-control-remoto-en-Git-1.png)

Ahora, en el IDE, dirígete a la pestaña 'Git' y elige la opción 'Manage Remotes'.

![configurar-control-remoto-en-Git-2.png](../assets/img/chapter-VI/sprint-1/configurar-control-remoto-en-Git-2.png)

Finalmente, como último paso, debes pegar el enlace copiado en el campo de dirección que solicita el IDE para el control remoto en Git.

![configurar-control-remoto-en-Git-3.png](../assets/img/chapter-VI/sprint-1/configurar-control-remoto-en-Git-3.png)

Si has seguido correctamente todos los pasos y directrices mencionados, entonces has completado la configuración con éxito. Ahora, solo necesitas realizar un commit y los cambios que hayas efectuado se guardarán en el repositorio de GitHub, ya sea que hayas realizado modificaciones en el código, creado nuevas ramas u otras acciones.

### 6.1.3. Source Code Style Guide & Conventions

A continuación, se presentan las convenciones de estilo de código que se utilizarán 
en el proyecto. Estas convenciones son importantes para mantener la coherencia y la 
legibilidad del código a lo largo del desarrollo.




### 6.1.4. Software Deployment Configuration

### Landing Page Deployment

Para desplegar la Landing Page desde GitHubPages hay que seguir los siguientes pasos:

**1. Ubicar el repositorio que tiene guardado el codigo fuente y dirigirse al apartado de configuración (settings):**


![repo-landing-page.png](../assets/img/chapter-VI/sprint-1/repo-landing-page.png)


**2. Seleccionar la sección pages:**


![pages-landing-page.png](../assets/img/chapter-VI/sprint-1/pages-landing-page.png)


**3. Configurar la rama que será usada para hacer deploy:**

![rama-landing-page.png](../assets/img/chapter-VI/sprint-1/rama-landing-page.png)

### Web services Deployment (API REST)

El despliegue de los servicios web se realizará en la nube utilizando el servicio de
GCP (Google Cloud platform). Para ello se utilizará el servicio de App Engine, que 
permite desplegar aplicaciones web y servicios en la nube de manera sencilla 
y escalable.




## 6.2. Landing Page & Mobile Application Implementation


### 6.2.1. Sprint 1


#### 6.2.1.1. Sprint Planning 1


#### 6.2.1.2. Sprint Backlog 1


#### 6.2.1.3. Development Evidence for Sprint Review

<table>
  <tr>
    <td align ="center" > <strong>Repository</strong></td>
    <td  align ="center" > <strong>Branch</strong></td>
    <td  align ="center" > <strong>Commit ID</strong></td>
    <td  align ="center" > <strong>Commit message</strong></td>
    <td  align ="center" > <strong>Commit Masagge body</strong></td>
    <td  align ="center" > <strong>Commit on (date)</strong></td>
  </tr>

  <tr>
    <td rowspan="16" align="center"> https://github.com/upc-2025-01-MetaSoft-App-Moviles/ElixirLine-Landing-Page.git </td>
    <td align="center"> Master </td>
    <td align="center"> b09ede62c8d4705d99faeb5abdd9e95ff47b86ce </td>
    <td align="center"> initial commit </td>
    <td align="center">  </td>
    <td align="center"> 2025/04/14 </td>
  </tr>

  <tr>
    <td align="center"> develop </td>
    <td align="center"> b09ede62c8d4705d99faeb5abdd9e95ff47b86ce </td>
    <td align="center"> chore: Added initial landing page project structure. </td>
    <td align="center">  </td>
    <td align="center"> 2025/04/14 </td>
  </tr>
  
  <tr>
    <td align="center"> feat/Benefits </td>
    <td align="center"> 05431e5c9484a19a83ff3e61fbcdb063a18c46c2 </td>
    <td align="center"> feat(benefits): benefits seccion added. </td>
    <td align="center">  </td>
    <td align="center"> 2025/05/08 </td>
  </tr>

  <tr>
    <td align="center"> feat/SuscriptionsAndVideo </td>
    <td align="center"> 5ec751d9fb45fa63c6dc90aa838f78a9c94208e0 </td>
    <td align="center"> feat(SubscriptionsAndVideo): added Subscriptions and Video section </td>
    <td align="center">  </td>
    <td align="center"> 2025/05/08 </td>
  </tr>

  <tr>
    <td align="center"> header-hero </td>
    <td align="center"> 1a8bc4e4f804d2b670bf9d3b57b3ed3cf35777f6 </td>
    <td align="center"> feat(index): added header area content </td>
    <td align="center">  </td>
    <td align="center"> 2025/05/07 </td>
  </tr>
</table>

#### 6.2.1.4. Testing Suite Evidence for Sprint Review


#### 6.2.1.5. Execution Evidence for Sprint Review


#### 6.2.1.6. Services Documentation Evidence for Sprint Review


#### 6.2.1.7. Software Deployment Evidence for Sprint Review


#### 6.2.1.8. Team Collaboration Insights during Sprint


## 6.3. Validation Interviews


### 6.3.1. Diseño de Entrevistas


### 6.3.2. Registro de Entrevistas


### 6.3.3. Evaluaciones según heurísticas


## 6.4. Video About-the-Product


# Conclusiones y recomendaciones


# Video About-the-team


# Bibliografía


# Anexos