# Capítulo VI: Product Implementation, Validation & Deployment

---

## 6.1. Software Configuration Management

En este punto del informe se describe las decisiones y los principios que ayudarán al equipo a garantizar la coherencia durante el desarrollo de la solución.

### 6.1.1. Software Development Environment Configuration

En este apartado se proporcionan los enlaces a las aplicaciones y productos de
software creados durante el ciclo del proyecto utilizando los programas correspondientes.

Con ese fin, se organizará en las siguientes secciones:
1. [ ] Project Management
2. [ ] Requirements Management
3. [ ] Product UX/UI Design
4. [ ] Software Development
5. [ ] Software Testing
6. [ ] Software Documentation

Asimismo, se clasificarán los elementos de estas secciones como rutas de referencia
(para software basado en modelos Saas) o rutas de descarga (para productos que se
ejecuten en las computadoras de los miembros del equipo) para cada uno de los productos
de software.

**Project Management**

Esta disciplina se fundamenta en la administración de proyectos y busca principalmente
la mejora de procesos y su entorno con el propósito de lograr los resultados 
esperados.

* Durante el ciclo digital del proyecto, se llevará a cabo la implementación de un 
producto de software basado en el modelo SaaS, el cual funcionará a través de un 
de una aplicación móvil con backend alojada en la nube.

**Requirements Management:**

Este proceso se enfoca en asegurar que una organización documente, verifique y satisfaga las
necesidades y expectativas de sus clientes, así como las de las partes interesadas internas
o externas.


* **Jira Software:** Esta es una plataforma que facilita la gestión de historias de usuario,
  organizándolas en epopeyas y evaluando su importancia en el programa según su prioridad y puntos
  de historia. Se utiliza debido a su capacidad para permitir que cada miembro del equipo tenga una
  vista en tiempo real de los avances en cada proyecto, contribuyendo con diferentes secciones o
  ajustando el flujo del proyecto según sea necesario.

**Product UX/UI Design**

Esta herramienta facilita la creación digital de modelos que se integran en la vida del consumidor.
En este caso, estamos desarrollando un modelo de sitio web compatible tanto con computadoras como
con dispositivos móviles.

Para lograrlo, utilizamos varias herramientas de diseño y colaboración, que incluyen:

1. **Uxpressia:** Uxpressia es una plataforma en línea especializada en el mapeo de la trayectoria del
   cliente. Nos ayuda a crear mapas de impacto y perfiles de usuario, como User Personas, Empathy Maps
   y Journey Maps. Puedes encontrar más información sobre Uxpressia en este [enlace](https://uxpressia.com/).

2. **MIRO:** MIRO es una pizarra digital colaborativa en línea que se adapta a diversas actividades
   colaborativas, como investigación, ideación, creación de lluvias de ideas y mapas mentales. Es una
   herramienta versátil que facilita el trabajo en equipo. Descubre más sobre MIRO en su
   [sitio web](https://miro.com/es/).

3. **Figma:** Figma es una herramienta de prototipado web y un editor de gráficos vectoriales. A
   diferencia de otras herramientas, Figma se ejecuta en línea, lo que permite crear modelos que
   funcionan tanto en navegadores web como en navegadores móviles. Puedes explorar
   Figma en [este enlace](https://www.figma.com/es-es/).

4. **Draw.io:** Esta es una aplicación de diagramación en línea que permite a los usuarios colaborar y
   trabajar juntos en tiempo real para crear una variedad de diseños, incluidos diagramas UML, mapas
   mentales, prototipos de software y otros tipos de diagramas. Puedes conocer más acerca de Lucid Chart
   en [este enlace](https://app.diagrams.net/).

5. **Overflow:** Overflow es una herramienta de diagramación que ofrece la posibilidad de colaborar en
   tiempo real. Utilizamos esta herramienta para crear diagramas de Userflows. Si deseas obtener más
   información sobre Overflow, visita su [sitio web](https://overflow.io/).

Estas herramientas nos ayudan a dar vida a nuestros diseños digitales y a garantizar que nuestros
productos sean accesibles y atractivos en diferentes plataformas.


**Software Development:**

El desarrollo de software es una metodología aplicada en la creación de productos de software. Esta
metodología se utiliza para establecer un proceso que guía el desarrollo del software, y cada uno de
sus pasos describe un enfoque específico para las distintas actividades que ocurren durante el proceso.

Aquí te presentamos algunas herramientas y tecnologías clave que utilizaremos en el proyecto:

1. **GitHub:** GitHub es una plataforma de repositorio comunitario que se utiliza para almacenar y
   gestionar los avances de proyectos realizados por grupos de personas. Puedes acceder al repositorio
   del proyecto en este [enlace](https://github.com/upc-2025-01-MetaSoft-App-Moviles).

2. **Webstorm:** Webstorm es un entorno de desarrollo de JetBrains, una empresa especializada en software,
   orientado al desarrollo web en JavaScript. Esta herramienta proporciona facilidades para probar
   sitios web en navegadores como Google Chrome. En nuestro proyecto, utilizaremos webstorm para
   trabajar con lenguajes como HTML, CSS y JavaScript. Obtén más información sobre WebStorm [aquí](https://www.jetbrains.com/webstorm/).

3. **HTML:** HTML es un lenguaje de marcado que se utiliza en el desarrollo de sitios web para crear
   hipertextos y enlazar a otros documentos. Este lenguaje proporciona herramientas para diseñar
   sitios web y se puede combinar eficazmente con CSS y JavaScript. En nuestro proyecto, utilizaremos
   HTML para implementar la documentación de la página web. Obtén más información sobre la edición de
   archivos HTML en WebStorm [aquí](https://www.jetbrains.com/help/idea/editing-html-files.html).

4. **CSS:** CSS es un lenguaje de diseño destinado al entorno web, que posibilita la mejora de la interfaz
   de usuario previamente diseñada al añadir elementos como colores y tamaños, entre otros. Además,
   es posible crear un estilo en CSS y compartirlo en el sitio web creado en HTML. Este lenguaje será
   empleado en la implementación del diseño de nuestra plataforma web. Puedes obtener más información
   sobre CSS en [enlace](https://www.jetbrains.com/help/idea/style-sheets.html).

5. **JavaScript:** Es un lenguaje de programación que es interpretado por otros programas. Funciona bajo
   el paradigma de programación orientada a objetos (POO), utilizando prototipos en lugar de clases
   para la implementación. Este lenguaje permite crear dinámicas para los usuarios a través de la
   lógica de programación y será utilizado en la creación de las interacciones dinámicas en la plataforma
   web. Puedes encontrar más detalles sobre JavaScript en [enlace](https://www.jetbrains.com/help/idea/style-sheets.html).

6. **Jetpack Compose:** Jetpack Compose es un kit de herramientas moderno para crear interfaces de usuario
   nativas en Android. Permite construir aplicaciones de manera más rápida y sencilla, utilizando un
   enfoque declarativo. En nuestro proyecto, utilizaremos Jetpack Compose para desarrollar la
   aplicación móvil. Puedes obtener más información sobre Jetpack Compose [aquí](https://developer.android.com/jetpack/compose).

7. **Kotlin:** Kotlin es un lenguaje de programación moderno y conciso que se utiliza para desarrollar
   aplicaciones Android. Es interoperable con Java y ofrece características avanzadas que facilitan el
   desarrollo. En nuestro proyecto, utilizaremos Kotlin como el lenguaje principal para la
   implementación de la aplicación móvil. Puedes encontrar más información sobre Kotlin [aquí](https://kotlinlang.org/).

8. **Room:** Room es una biblioteca de persistencia de datos que forma parte de Android Jetpack. Proporciona
   una capa de abstracción sobre SQLite, lo que facilita el acceso a la base de datos y mejora la
   eficiencia del desarrollo. En nuestro proyecto, utilizaremos Room para gestionar la base de datos
   local de la aplicación móvil. Puedes obtener más información sobre Room [aquí](https://developer.android.com/training/data-storage/room).

9. **Retrofit:** Retrofit es una biblioteca de cliente HTTP para Android y Java. Facilita la
   comunicación con servicios web RESTful y simplifica la gestión de solicitudes y respuestas. En
   nuestro proyecto, utilizaremos Retrofit para realizar llamadas a la API y obtener datos del
   servidor. Puedes encontrar más información sobre Retrofit [aquí](https://square.github.io/retrofit/).

Estas herramientas y tecnologías desempeñarán un papel fundamental en la creación exitosa de nuestro
producto de software.

**Software Testing:**

Se trata de la acción de evaluar los elementos y el funcionamiento del software sometido a prueba
mediante procesos de validación y verificación.

**Lenguaje Gherkin:** Este lenguaje, conocido como DSL (Lenguaje Específico de Dominio), está diseñado
específicamente para abordar problemas particulares. Además de poder ser interpretado en código,
permite agregar historias de usuario del programa junto con sus componentes correspondientes, como
Característica, Escenario, Ejemplo, Esquema de Escenario, Dado, Cuando, Entonces y Y.

**Software Documentation**

Se refiere a textos escritos o ilustraciones que acompañan al software de computadora o están
integrados en su código fuente. Esta documentación tiene como objetivo explicar cómo funciona el
software o cómo utilizarlo.

### 6.1.2. Source Code Management

A continuación, se describe la gestión del código fuente, también conocida por las siglas SCM (Source Code Management). Su función principal es rastrear los cambios que realizará el equipo durante el desarrollo de su proyecto en el repositorio de código fuente. Se utilizará como un sistema de control de versiones que lepermitirá realizar un seguimiento de los cambios realizados por miembros o desarrolladores individuales del proyecto. Además, es importante tener en cuenta que usaremos GitHub como nuestro sistema de control de versiones.

1. [ ] URL de la organización: upc-2025-01-MetaSoft-App-Moviles - https://github.com/upc-2025-01-MetaSoft-App-Moviles

2. [ ] URL del repositorio de la Landing Page: ElixirLine -Landing-Page - https://github.com/upc-2025-01-MetaSoft-App-Moviles/ElixirLine-Landing-Page

3. [ ] URL del repositorio de la aplicación móvil: ElixirLine-mobile - 

4. [ ] URL del repositorio del Back-End: ElixirLine-Platform - https://github.com/upc-2025-01-MetaSoft-App-Moviles/ElixirLine-Platform

**GitFlow**

GitFlow es un modelo alternativo para la creación de ramas en Git que se ha convertido en una herramienta esencial para muchos desarrolladores en los últimos años. Este flujo de trabajo de control de versiones, desarrollado y popularizado por Vicent Driessen, desempeña un papel crucial en la gestión de las versiones de un código, facilitando la creación ordenada de nuevas características (Features) y correcciones de problemas urgentes (Hotfixes).

![GitFlow.png](../assets/img/chapter-VI/sprint-1/GitFlow.png)

Como se mencionó previamente, GitFlow opera con ramas o "branches". A continuación, se detallan las ramas que se utilizarán en el flujo de trabajo de nuestro proyecto.

* **Main Branches:**
    * **Main:** Esta es la rama principal desde la cual se ramifican todas las demás. Contendrá la versión más reciente junto con las versiones anteriores creadas por los desarrolladores. Aquí se mantendrá el historial oficial de las versiones publicadas.
    * **Develop:** Esta rama puede ser creada a partir de la rama principal (Main) y contendrá todas las características (Features) estables. A través de esta rama, el equipo podrá integrar las funcionalidades de manera efectiva.

* **Support Branches**
  A diferencia de las ramas principales, estas ramas secundarias tienen una vida útil limitada, ya que se eliminan al fusionarse con sus ramas primarias.
    * **Feature:**
        * Se ramifica de: develop
        * Debe fusionarse de nuevo en: develop
        * Se utilizan para desarrollar las nuevas funciones que se integrarán en la próxima versión. Es importante destacar que esta rama existe únicamente mientras está en proceso de desarrollo. Sin embargo, una vez que el desarrollador haya completado esa función, se fusionará nuevamente con la rama "develop".

* **Convenciones para nombrar los Features:**
    * **Feture Branch:** feature/name
      **Example:**
        1. feature/welcome
        2. feature/about
        3. feture/myfeture
    * **Conventional Commits**
      El commit debe seguir la siguiente estructura:
      **\<type> [optional scope]: \<description>**
      **[optional body]**
      **[optional footer(s)]**
        * **Type:**
          **1\. feat:** Cuando se agrega un nuevo feature.
          **2\. fix:** cuando corriges un error.
          **3\. build:** cuando afectan los componentes de compilación como la herramienta de compilación, las dependencias o la version del proyecto.
          **4\. chore:** modificaciones privadas del código.
          **5\. docs:** commits que afectan solo a la documentación.
          **6\. refractor:** commits que reescriben o reestructura el código, pero no cambia el comportamiento.
          **7\. perf:** commits especiales que mejoran el rendimiento.
          **8\. style:** commits que no afectan el programa. (espacios en blanco, formato, puntos o comas faltantes).
          **9\. test:** commits que agregan pruebas.
        * **Scope**
          Ofrece información contextual adicional. Aunque es opcional, es beneficioso incluirlo para proporcionar a los desarrolladores una descripción más detallada del commit.
          **\<description>**
          Es una parte obligatoria del formato de los commits. Siempre debemos usar lenguaje en modo imperativo y evitar escribir en mayúsculas
          **[optional body]**
          El cuerpo es opcional y, cuando se utiliza, debe explicar la motivación detrás del cambio y contrastarlo con el comportamiento anterior. Es ideal para mencionar identificadores de problemas y sus relaciones.
          **[optional footer(s)]**
          Esta sección es opcional y puede incluir información sobre cambios significativos. Puede hacer referencia al problema por su identificación y, en esta sección, se incluyen los cambios importantes precedidos por "BREAKING CHANGES:" seguido de uno o dos saltos de línea.
          **Ejemplos:**
            1. feat(welcome): add welcome section
            2. build(release): bump version to 1.0.0
            3. style: remove empty line
            4. feat(sign up): add the button to sign up
            5. feat!: email the costumer when product is shipped
            6. feat: remove ticket list endpoint
               refers to JIRA-1337
               BREAKING CHANGES: ticket enpoints no longer supports list all entites.

Como se mencionó previamente, la gestión de nuestro código fuente se llevará a cabo mediante
GitHub. El IDE utilizado en este caso, WebStorm, debe estar vinculado directamente al
repositorio creado por nuestra StartUp. De esta manera, cada commit realizado por
un miembro del equipo se subirá automáticamente y se cargará en el GitHub de la organización. Las instrucciones para completar con éxito este proceso de emparejamiento se detallan a continuación:

* **Activar el controlador de versiones del IDE**
  Dado que utilizaremos GitHub para gestionar nuestro código, la opción que debe estar
  habilitada o seleccionada es aquella que indique que el sistema de control se realizará
  mediante Git. Para hacer esto, siga los siguientes pasos:

    1. Diríjase a la pestaña "VCS" en WebStorm.
    2. Luego, seleccione la opción "Enable Version Control Integration".

![activar-el-controlador-de-versiones-1.png](../assets/img/chapter-VI/sprint-1/activar-el-controlador-de-versiones-1.png)

Ahora se debe seleccionar el sistema de control a través de Git y, por último aceptar los cambios.

![activar-el-controlador-de-versiones-2.png](../assets/img/chapter-VI/sprint-1/activar-el-controlador-de-versiones-2.png)

* **Aregar una cuenta de GitHub, siga estos pasos:**
    1. Diríjase a la sección de configuración en su aplicación.
    2. Dentro de la pestaña 'File', busque y seleccione la opción 'Settings'.
    3. En la configuración, busque la sección de version control.
    4. Agregue su cuenta de GitHub para obtener acceso a los repositorios.


![aregar-una-cuenta-de-GitHub-1.png](../assets/img/chapter-VI/sprint-1/aregar-una-cuenta-de-GitHub-1.png)

![aregar-una-cuenta-de-GitHub-2.png](../assets/img/chapter-VI/sprint-1/aregar-una-cuenta-de-GitHub-2.png)

* **Configurar el nombre de usuario de Git:** Una vez que hayas establecido el sistema de control de versiones que se vinculará con tu IDE, deberás ingresar la cuenta que utilizarás. Para hacerlo, sigue estos pasos:
    1. Realiza un commit en tu proyecto. Durante este proceso, se te solicitará que ingreses tu nombre de usuario de Git.
    2. Después de haberlo añadido, todos los cambios se guardarán en el repositorio especificado en esa plataforma, siempre y cuando des la orden correspondiente.
    3. Para configurar tu nombre de usuario de Git, primero selecciona la opción 'commit' que se encuentra dentro de la pestaña 'Git'.


![configurar-el-nombre-de-usuario-de-Git-1.png](../assets/img/chapter-VI/sprint-1/configurar-el-nombre-de-usuario-de-Git-1.png)


* **Guardar el progreso en GitHub:** Con todo configurado en WebStorm, ahora puedes subir tu código a GitHub sin problemas. Simplemente dirígete a la opción 'GitHub' que se encuentra en la pestaña 'Git' y comparte el proyecto.


![guardar-el-progreso-en-GitHub-1.png](../assets/img/chapter-VI/sprint-1/guardar-el-progreso-en-GitHub-1.png)


![guardar-el-progreso-en-GitHub-2.png](../assets/img/chapter-VI/sprint-1/guardar-el-progreso-en-GitHub-2.png)

* **Configurar la propiedad del repositorio en GitHub:** Ahora, solo necesitas configurar la ubicación del repositorio. El código ya debería estar guardado en GitHub, pero solo estará presente en tu propia cuenta. Para cambiar la propiedad y transferirla a la organización deseada, sigue estos pasos:
    1. Ingresa al repositorio creado en GitHub.
    2. Selecciona la pestaña 'settings'
    3. Dirigite al apartado de 'DangerZone'
    4. Luego da click en 'transfer'
    5. Finalmente elegimos el nuevo lugar para guardar el repositorio.


![configurar-la-propiedad-del-repositorio-en-GitHub-2.png](../assets/img/chapter-VI/sprint-1/configurar-la-propiedad-del-repositorio-en-GitHub-2.png)

![configurar-la-propiedad-del-repositorio-en-GitHub-3.png](../assets/img/chapter-VI/sprint-1/configurar-la-propiedad-del-repositorio-en-GitHub-3.png)

![configurar-la-propiedad-del-repositorio-en-GitHub-4.png](../assets/img/chapter-VI/sprint-1/configurar-la-propiedad-del-repositorio-en-GitHub-4.png)


* **Configurar control remoto en Git:** Por último, dado que el repositorio ahora está bajo la propiedad de la empresa y depende de ella, es necesario acceder al control remoto del código. Para hacerlo, simplemente ingresa al repositorio creado y copia la URL del repositorio.

![configurar-control-remoto-en-Git-1.png](../assets/img/chapter-VI/sprint-1/configurar-control-remoto-en-Git-1.png)

Ahora, en el IDE, dirígete a la pestaña 'Git' y elige la opción 'Manage Remotes'.

![configurar-control-remoto-en-Git-2.png](../assets/img/chapter-VI/sprint-1/configurar-control-remoto-en-Git-2.png)

Finalmente, como último paso, debes pegar el enlace copiado en el campo de dirección que solicita el IDE para el control remoto en Git.

![configurar-control-remoto-en-Git-3.png](../assets/img/chapter-VI/sprint-1/configurar-control-remoto-en-Git-3.png)

Si has seguido correctamente todos los pasos y directrices mencionados, entonces has completado la configuración con éxito. Ahora, solo necesitas realizar un commit y los cambios que hayas efectuado se guardarán en el repositorio de GitHub, ya sea que hayas realizado modificaciones en el código, creado nuevas ramas u otras acciones.

### 6.1.3. Source Code Style Guide & Conventions

A continuación, se presentan las convenciones de estilo de código que se utilizarán 
en el proyecto. Estas convenciones son importantes para mantener la coherencia y la 
legibilidad del código a lo largo del desarrollo.

Dado que en este proyecto se emplearán varios lenguajes, como HTML, CSS, JavaScript, 
C# para el desarrollo de la aplicación móvil, así como Gherkin para el 
proceso de pruebas del programa, a continuación, se detallarán y describirán las 
reglas y recomendaciones generales que se tendrán en cuenta al utilizarlos.

**Nomenclatura General**

Para los nombres de variables, objetos, elementos y funciones que se utilicen en el
proyecto, se emplearán términos en inglés que estén relacionados con lo que representan.
No se utilizarán mayúsculas en estos nombres, ya que, de acuerdo con W3Schools (sin fecha),
la combinación de mayúsculas y minúsculas puede dificultar la legibilidad del código. 
En su lugar, se optará por utilizar exclusivamente letras minúsculas, lo que contribuirá 
a una mayor claridad en el código.

Ejemplos de nomenclatura estándar, siguiendo las recomendaciones de Google (s.f.):

    ```
    .gallery {}
    .video {}
    .login {}
    ```

Estas pautas de nomenclatura ayudarán a mantener una coherencia en el código y facilitarán su comprensión.

**Sangría**

La sangría es una parte fundamental de la legibilidad del código. En este proyecto, 
se utilizará una sangría de 2 espacios para el código HTML, CSS y JavaScript. Esta 
elección se basa en las recomendaciones de Google (s.f.) y W3Schools (sin fecha), 
que sugieren que una sangría adecuada mejora la claridad y la estructura del código.

    ```
    <!DOCTYPE html>
    <html>
      <head>
        <title>Título del Documento</title>
      </head>
      <body>
        <h1>Encabezado Principal</h1>
        <p>Este es un párrafo dentro del cuerpo del documento.</p>
      </body>
    </html>
    ```

Ejemplo de formato estándar de sangría en CSS, conforme a las recomendaciones de W3Schools (s.f):

    ```
    body {
      background-color: #f0f0f0; /* Color de fondo */
      font-family: Arial, sans-serif; /* Fuente del texto */
    }
    ```

Ejemplo de nomenclatura estándar de la sangría en JavaScript según W3School (s.f.):

    ```
    function myFunction() {
      var x = 5; // Declaración de variable
      if (x > 0) {
        console.log("x es positivo"); // Mensaje en la consola
      }
    }
    ```

**Especificaciones generales**

A continuación, detallaremos las reglas específicas necesarias para comprender el código 
de nuestra aplicación en cada lenguaje.

**HTML**

HTML, acrónimo de HyperText Markup Language en inglés, es el lenguaje de marcado que se utiliza
para estructurar y presentar contenido en la web. A continuación, se presentan las reglas de
nomenclatura y estilo de código que se aplicarán al HTML en este proyecto:

1. [ ]  Declare Document Type La declaración del tipo de documento debe realizarse en la primera línea del código. Según 
 las recomendaciones de Google (s.f.), se prefiere la sintaxis de HTML5 para todos los documentos HTML. Para declararla, simplemente copia lo siguiente:

    ```
    <!DOCTYPE html>
    ```

2. [ ] **Blank Lines:** Se recomienda dejar una línea en blanco entre las etiquetas de apertura y cierre de cada 
   bloque. Esto mejora la legibilidad del código y facilita su comprensión, de acuerdo con
    las pautas de W3School (s.f.).

    ```
    <!DOCTYPE html>
    <html>
      <head>
        <title>Título del Documento</title>
      </head>
    
      <body>
        <h1>Encabezado Principal</h1>
        <p>Este es un párrafo dentro del cuerpo del documento.</p>
      </body>
      
    </html>
    ```

3. [ ] **Quote attribute Values:** 
   Se recomienda utilizar comillas dobles para los valores de los atributos. Esta convención es 
   ampliamente aceptada y mejora la consistencia del código, como se indica en las pautas de Google (s.f.).

    ```
    <a href="https://www.ejemplo.com" target="_blank">Enlace</a>
    ```


4. [ ] **Never Skip the _< title >_ Element:** El elemento _< title >_ es fundamental para la accesibilidad y la 
   optimización de motores de búsqueda (SEO). Se recomienda incluirlo en todas las páginas HTML, ya que proporciona información importante sobre el contenido de la página. 
   Esta recomendación se basa en las pautas de Google (s.f.).

    ```
    <title> Guía de Estilo HTML y Convenciones de Codificación </title>
    ```

5. [ ] **HTML Line-Wrapping:** 
   Se recomienda utilizar un ancho de línea de 80 caracteres para el código HTML. Esto mejora la legibilidad y facilita la revisión del código, como se sugiere en las pautas de Google (s.f.).

    ```
    <button mat-icon-button color='primary' class="menu-button"
    (click)="openMenu()">
    <mat-icon>menu</mat-icon>
    </button>
    ```

    Este estilo de formateo ayuda a mantener un código más legible y facilita la identificación de los elementos y su jerarquía en la estructura del documento HTML.


**CSS**

CSS, conocido por sus siglas en inglés, Cascading Style Sheets (Hojas de Estilo en Cascada), es un lenguaje que se enfoca en definir y mejorar la presentación de un documento basado en HTML. A continuación, se presentan las directrices que debemos seguir al utilizar CSS:

1. [ ] **Shorthand Properties** Se recomienda utilizar abreviaturas de propiedades y declarar los campos de los elementos en la menor cantidad de líneas posible, según las pautas de Google (sin fecha). Esto aumenta la eficiencia del código y lo hace más legible. Además, se debe evitar agregar unidades después del valor cero. Aquí tienes un ejemplo:

    ```
    border-top: 0;
    font: 100%/1.6 palatino, georgia, serif;
    padding: 0 1em 0;
    ```

    Siguiendo estas recomendaciones, se puede lograr un código CSS más conciso y fácil de entender.

1. [ ] **Declaration Stops:** Es importante incluir un punto y coma al final de cada declaración en CSS, al igual 
   que en la mayoría de los lenguajes de programación. Siguiendo las pautas de Google (sin fecha), esta práctica contribuye a mantener la coherencia en el código. A continuación, se muestra un ejemplo:

    ```
    h1 {
      color: blue;
      font-size: 24px;
      text-align: center;
    }
    ```

    El uso consistente de puntos y comas al final de las declaraciones CSS ayuda a prevenir errores y mejora la claridad del código.

1. [ ] **Property Name Stops** Es necesario incluir un espacio entre los dos puntos que siguen al nombre de una propiedad y el valor correspondiente. Siempre se debe colocar un solo espacio después de los dos puntos, pero no antes. A continuación, se muestra un ejemplo siguiendo esta convención estándar de Google (s.f):

    ```
    h1 {
      color: blue;
      font-size: 24px;
      text-align: center;
    }   
    ```

    Mantener esta consistencia en la colocación de espacios ayuda a que el código CSS sea más legible y fácil de entender.

1. [ ] **Declaration Block Separation:** Es esencial utilizar un espacio separador después del nombre de un selector de 
elemento y antes de la llave que inicia un bloque de declaración CSS. Además, la llave de apertura del bloque debe estar en la misma línea que el selector. Aquí tienes un ejemplo siguiendo esta convención estándar de Google (sin fecha):

    ```
    h1 {
      color: blue;
      font-size: 24px;
      text-align: center;
    }
    ```

    El cumplimiento de estas directrices ayuda a mantener la consistencia y la legibilidad en el código CSS.

1. [ ] **CSS quotation Marks:** No se deben utilizar comillas dobles (") en el código CSS; en su lugar, se permiten 
   y deben emplearse comillas simples (') únicamente para selectores de atributos y valores de propiedades. Ejemplo conforme a las pautas estándar de Google (sin fecha):

    ```
    .gallery {
      background-image: url('image.jpg');
      background-size: cover;
    }
    ```
    Este ejemplo muestra el uso de comillas simples para encerrar el valor de la propiedad background-image en CSS, lo cual es una práctica común y aceptada.

**JavaScript**

JavaScript es un lenguaje de programación que permite especificar de manera precisa las acciones que debe realizar el navegador web, incluyendo el orden de ejecución de tareas y la frecuencia con la que se deben llevar a cabo. A continuación, se presentan las pautas para el uso de JavaScript en nuestro proyecto:

1. [ ] **Spaces around operators** Es importante añadir espacios alrededor de cada operador matemático y comas que se utilicen en el código JavaScript. A continuación, se muestra un ejemplo siguiendo la convención estándar de W3Schools (sin fecha):

    ```
    let x = y + z;
    const myArray = ['Volvo', 'Saab', 'Fiat'];
    ```

    El uso consistente de espacios alrededor de operadores y comas mejora la legibilidad del código JavaScript.

1. [ ] **Simple Statement's End** Es fundamental que una instrucción simple finalice con un punto y coma, tal como es el caso en muchos otros lenguajes de programación. A continuación, se muestra un ejemplo que cumple con la convención estándar de W3Schools (sin fecha):

    ```
    let x = v + 7;
    const myArray = ['Volvo', 'Saab', 'Fiat'];
    El uso de punto y coma al final de cada instrucción ayuda a garantizar la estructura correcta del código JavaScript y a evitar posibles errores.
    ```

1. [ ] **Beginning and End of Function** Un bloque de función debe incluir una llave al final de la primera línea, de modo que el cierre de la función esté en la última línea, sin necesidad de un punto y coma. Este mismo principio se aplica a las estructuras condicionales y los bucles. A continuación, se muestra un ejemplo que cumple con la convención estándar de W3Schools (sin fecha):

    ```
    function myFunction() {
      let x = 5;
      if (x > 0) {
        console.log("x es positivo");
      }
    }   
    ```
    En este ejemplo, se observa que la llave de apertura de la función está en la misma línea que la declaración de la función, y la llave de cierre está al final del bloque, lo que sigue las pautas recomendadas.


1. [ ] **Object Rules Para la creación de un objeto:** Al igual que en una función, se comienza con una llave al 
   final de la primera línea. Sin embargo, en este caso, la llave de cierre debe ir seguida de un punto y coma. Para definir las propiedades del objeto, se utilizan dos puntos y un espacio para separar el nombre de la propiedad de su valor. Si el valor es un string, se debe encerrar entre comillas dobles. A continuación, se muestra un ejemplo siguiendo la convención estándar de W3Schools (sin fecha):

    ```
    const person = {
      firstName: "John",
      lastName: "Doe",
      age: 50,
      eyeColor: "blue"
    };
    ```

    En este ejemplo, el objeto person está formateado de acuerdo con estas pautas, lo que mejora la legibilidad y la estructura del código JavaScript.

**Gherkin:**

Gherkin es un Lenguaje Específico de Dominio (DSL por sus siglas en inglés) que se utiliza para resolver problemas específicos mediante la generación de casos de prueba que validan una característica en diversos escenarios. Gherkin incluye varios elementos, entre los cuales los más conocidos y utilizados son Feature, Scenario, Example, Given, When y Then. A continuación, se presentan las pautas que debemos seguir al utilizar Gherkin en nuestro código:

1. [ ] **Discernible Given-When-Then Blocks** Es importante aplicar sangría a los elementos que representan los pasos a seguir en un escenario. En el caso de "And", se debe aplicar una sangría adicional. Siguiendo la recomendación de Keiblinger (2021), este enfoque ayuda a identificar rápidamente las partes que componen un escenario. A continuación, se muestra un ejemplo:

    ```gherkin
    
    Feature: Ingreso de requisitos con claridad
      Scenario: Ingreso de requisitos con claridad
        Given que en el formulario de ingreso de oferta laboral
          And el campo de requisitos está vacío
        When escribo claramente los requisitos
          And mi oferta solo aparecerá a quienes cumplan con estos
        Then se mostrará el mensaje
          And se habilita la opción
    ```

    En este ejemplo, se ha aplicado la sangría de manera adecuada para resaltar los pasos del escenario, y se ha utilizado una sangría adicional para los pasos que comienzan con "And". Esto mejora la legibilidad y la comprensión de los escenarios escritos en Gherkin.

1. [ ] **Step with Tables** Conforme a la recomendación de Keiblinger (2021), cuando sea necesario introducir valores en partes del escenario, se debe emplear una tabla o crear un formulario que refleje esa parte del escenario. Antes de esta representación, se deben colocar dos puntos. Aquí tienes un ejemplo:
Then se mostrará el mensaje:

    ```gherkin
    | Mensaje |
    | Se completaron los requisitos adecuadamente |
    ```

    Este enfoque permite una representación clara y estructurada de los valores relacionados con una parte específica del escenario.


1. [ ] **Reducing Noise** Para evitar la acumulación de demasiadas líneas de código en un escenario, es recomendable incluir valores por defecto dentro de los pasos para campos que no sean muy relevantes para ese escenario en particular. Los valores "estándar" que se coloquen deben estar entre comillas simples. Siguiendo el consejo de Keiblinger (2021), esta práctica contribuye significativamente a la reducción del tamaño del código. A continuación, se muestra un ejemplo:

    ```gherkin
    When escribo claramente los requisitos 'dominio en C'
    ```

    En este ejemplo, se ha incluido un valor por defecto ('dominio en C') entre comillas simples dentro del paso para representar un campo que no es esencial en ese escenario. Esto ayuda a mantener el escenario más conciso y legible.


1. [ ] **Scenarios Separator** Para separar dos escenarios, se debe insertar un salto de línea y, según la sugerencia de Keiblinger (2021), si es posible, agregar una línea de comentario para facilitar la visualización de estos. De esta manera, se identifica rápidamente el inicio y el fin de un escenario. A continuación, se presenta un ejemplo:

    ```gherkin
    Scenario: Ingreso de requisitos con claridad
    Given que en el formulario de ingreso de oferta laboral
    When escribo claramente los requisitos
    Then se mostrará el mensaje
    And mi oferta solo aparecerá a quienes cumplan con estos
    And se habilita la opción
    
    # --------------------------
    
    Scenario: Otro escenario
    Given que en otro contexto
    When ocurre algo diferente
    Then se muestra otro resultado
    ```

    En este ejemplo, se ha agregado un salto de línea entre los dos escenarios y se ha incluido una línea de comentario como separador para mejorar la visualización y la identificación de cada escenario.

**C#:**

C# es un lenguaje de programación desarrollado por Microsoft en el año 2000 como parte de su plataforma .NET. Desde su creación, C# ha evolucionado significativamente, convirtiéndose en una herramienta esencial para el desarrollo de una amplia gama de aplicaciones, desde software de escritorio hasta aplicaciones web y móviles, así como servicios en la nube. Su diseño moderno y su integración con el ecosistema de .NET lo han consolidado como una opción preferida para muchos desarrolladores a nivel global.

A continuación, se presentan las pautas que debemos seguir al utilizar C# en nuestro código:

1. [ ] **Espacios alrededor de operadores:** Es importante añadir espacios alrededor de operadores de asignación, 
   aritméticos, lógicos y de comparación. Esto mejora la legibilidad del código y sigue las convenciones oficiales del lenguaje.

    ```csharp
    int x = 5;
    if (x > 0 && x < 10)
    {
        Console.WriteLine("x está entre 0 y 10");
    }
    ```

    Este formato permite al lector identificar claramente las operaciones que se están realizando.

2. [ ] **Finalización de sentencias simples:** Cada instrucción simple debe finalizar con un punto y coma (;). Este 
   elemento sintáctico es obligatorio en C# y garantiza el correcto cierre de las operaciones.

    ```csharp
    int x = 5;
    Console.WriteLine("Hola, mundo");
    ```

    El uso correcto del punto y coma evita errores de compilación y mantiene una estructura limpia.

3. [ ] **Inicio y cierre de funciones y estructuras de control:** Las llaves de apertura deben colocarse al final de 
   la línea de declaración, y la llave de cierre debe ir sola en la última línea del bloque. Esto aplica tanto a funciones como a condicionales y bucles.

    ```csharp
    void MiFuncion()
    {
        if (x > 0)
        {
            Console.WriteLine("x es positivo");
        }
    }
    ```

    Este estilo de formateo mejora la claridad y la organización del código.

4. [ ] **Reglas para objetos (clases y propiedades):** Al crear clases u objetos, se recomienda seguir estas pautas:

   * Usar PascalCase para nombres de clases y propiedades.
   * Separar cada propiedad con una línea.
   * Encapsular campos con propiedades.
   * Colocar las llaves de apertura/cierre correctamente.
   * Cerrar el bloque de clase sin punto y coma.

    ```csharp
    public class Persona
    {
        public string Nombre { get; set; }
        public int Edad { get; set; }

        public void Saludar()
        {
            Console.WriteLine($"Hola, soy {Nombre} y tengo {Edad} años.");
        }
    }
    ```

    Este formato ayuda a mantener un código limpio y fácil de entender.

5. [ ] **Definición de métodos y constructores:** Los métodos deben nombrarse con verbos que indiquen acción. Es 
   recomendable agrupar constructores, métodos públicos y privados usando regiones opcionales para facilitar la navegación.

    ```csharp
    public class Persona
    {
        public string Nombre { get; set; }
        public int Edad { get; set; }

        // Constructor
        public Persona(string nombre, int edad)
        {
            Nombre = nombre;
            Edad = edad;
        }

        // Método público
        public void Saludar()
        {
            Console.WriteLine($"Hola, soy {Nombre} y tengo {Edad} años.");
        }
    }
    ```

    Este enfoque mejora la organización del código y facilita su comprensión.

6. [ ] **Uso de async/await en operaciones asíncronas:** Las operaciones que acceden a recursos externos (como 
   archivos o base de datos) deben declararse con async y usar await para evitar bloqueos.

    ```csharp
    public async Task<string> ObtenerDatosAsync()
    {
        using (HttpClient client = new HttpClient())
        {
            string resultado = await client.GetStringAsync("https://api.ejemplo.com/datos");
            return resultado;
        }
    }
    ```

    Este enfoque mejora la eficiencia y la capacidad de respuesta de la aplicación.

7. [ ] **Convenciones de nomenclatura:**

   * Clases: PascalCase → MiServicio, ArchivoManager
   * Métodos: PascalCase → CalcularSuma, GuardarCambios
   * Variables: camelCase → resultadoTotal, contador
   * Interfaces: Prefijo "I" → IRepositorio, IServicioLogger

    ```csharp
    public interface IRepositorio
    {
        void Guardar(Entidad entidad);
        Entidad ObtenerPorId(int id);
    }
   
    public class ServicioUsuario : IRepositorio
    {
        public void Guardar(Entidad entidad)
        {
            // Lógica para guardar la entidad
        }

        public Entidad ObtenerPorId(int id)
        {
            // Lógica para obtener la entidad por ID
            return new Entidad();
        }
    }

    ```
    Este estilo de nomenclatura ayuda a identificar rápidamente el propósito de cada elemento en el código.

8. [ ] **Comentarios XML y documentación:** Usar comentarios XML para documentar métodos y clases públicas. Esto permite generar documentación automáticamente y ayuda a otros desarrolladores a entender la intención del código.

    ```csharp
    /// <summary>
    /// Clase que representa un servicio de usuario.
    /// </summary>
    public class ServicioUsuario
    {
        /// <summary>
        /// Guarda una entidad en el repositorio.
        /// </summary>
        /// <param name="entidad">La entidad a guardar.</param>
        public void Guardar(Entidad entidad)
        {
            // Lógica para guardar la entidad
        }
    }
    ```

    Esta práctica es esencial en proyectos colaborativos y de largo plazo.

**Kotlin – Android Development**

Kotlin es un lenguaje moderno, conciso y seguro, recomendado por Google para el desarrollo de aplicaciones Android. Su sintaxis clara permite escribir código robusto, mantenible y expresivo. A continuación, se presentan las pautas que deben seguirse al utilizar Kotlin en nuestro proyecto Android:

1. [ ] Espacios alrededor de operadores
   Es importante utilizar espacios alrededor de operadores matemáticos, lógicos y de comparación para mejorar la legibilidad del código Kotlin.

    ```kotlin
    val x = 5
    if (x > 0 && x < 10) {
        println("x está entre 0 y 10")
    }
    ```
   
    Esto permite que el código se lea de forma fluida y se reduzcan los errores visuales.

2. [ ] Finalización de sentencias simples
   En Kotlin no es obligatorio usar punto y coma (;) al final de una línea, y se debe evitar su uso salvo en casos muy específicos (como múltiples instrucciones en una sola línea, que también deben evitarse).

    ```kotlin
    val x = 5
    println("Hola, mundo")
    ```
   
    Este estilo de escritura ayuda a mantener el código limpio y fácil de seguir.

3. [ ] Llaves en funciones y estructuras de control
   Las llaves deben abrirse al final de la línea de definición del bloque (if, for, fun, etc.) y cerrarse en una nueva línea. Es preferible no usar bloques de una sola línea sin llaves, aunque Kotlin lo permite.

    ```kotlin
    fun miFuncion() {
        if (x > 0) {
            println("x es positivo")
        }
    }
    ```
   
    Este formato mejora la claridad y la organización del código.

4. [ ] Definición de clases y objetos
   Las clases deben declararse con class, seguidas por las propiedades en el constructor primario (si es necesario). Los bloques deben estar correctamente tabulados y las propiedades deben seguir un orden lógico.

    ```kotlin
    class Persona(val
        nombre: String,
        var edad: Int
    ) {
        fun saludar() {
            println("Hola, soy $nombre y tengo $edad años.")
        }
    }
    ```
   
    Este estilo de declaración ayuda a mantener un código limpio y fácil de entender.

5. [ ] Declaración de variables

   * Usar val para variables inmutables (preferido).
   * Usar var solo cuando se necesite mutabilidad.
   * Utilizar nombres descriptivos en camelCase.

    ```kotlin
    val nombre = "Juan"
    var edad = 25
    ```
    
    Este enfoque mejora la claridad del código y evita confusiones sobre la mutabilidad de las variables.

6. [ ] Funciones pequeñas y expresivas
   Cada función debe realizar una sola tarea y su nombre debe describir claramente su propósito. Las funciones que retornan una sola expresión pueden usar la sintaxis de expresión.

    ```kotlin
    fun sumar(a: Int, b: Int): Int {
        return a + b
    }

    fun sumar(a: Int, b: Int) = a + b
    ```
   
    Este estilo de escritura ayuda a mantener el código limpio y fácil de seguir.

7. [ ] Uso de lambdas y funciones de orden superior
   Aprovechar la sintaxis funcional de Kotlin para colecciones y operaciones simples.

    ```kotlin
    val numeros = listOf(1, 2, 3, 4, 5)
    val cuadrados = numeros.map { it * it }
    println(cuadrados) // [1, 4, 9, 16, 25]
    ```

    Este enfoque mejora la legibilidad y la expresividad del código.

8. [ ] Null Safety y uso de ? y !!
   Evitar el uso de !! (not-null assertion operator). Usar operadores seguros (?., ?:, let) para prevenir excepciones de null.

    ```kotlin
    val nombre: String? = null
    val longitud = nombre?.length ?: 0
    ```
    Este enfoque ayuda a prevenir errores de null y mejora la seguridad del código.

9. [ ] Estructura de un archivo Kotlin
   El orden recomendado en un archivo de clase es:

   * Importaciones
   * Declaración de clase
   * Propiedades
   * Constructores
   * Métodos públicos
   * Métodos privados
   * Clases internas / objetos anidados

    ```kotlin
   package com.ejemplo.app

    import android.os.Bundle
    import androidx.appcompat.app.AppCompatActivity
    
    class MainActivity : AppCompatActivity() {

        private val mensaje = "Hola mundo"

        override fun onCreate(savedInstanceState: Bundle?) {
            super.onCreate(savedInstanceState)
            saludar()
        }

        private fun saludar() {
            println(mensaje)
        }
    }
    ```

    Este orden ayuda a mantener una estructura clara y organizada en el código.

10. [ ] Documentación y comentarios
    Se recomienda utilizar comentarios en formato KDoc (/** ... */) para funciones, clases y propiedades públicas.

    ```kotlin
    /**
     * Clase que representa una persona.
     *
     * @property nombre El nombre de la persona.
     * @property edad La edad de la persona.
     */
    
    class Persona(val nombre: String, var edad: Int) {
        /**
         * Saluda a la persona.
         */
        fun saludar() {
            println("Hola, soy $nombre y tengo $edad años.")
        }
    }
    ```
    
    Este enfoque mejora la documentación del código y facilita su comprensión por parte de otros desarrolladores.

**Swift para Desarrollo iOS**

Swift es un lenguaje de programación moderno y potente desarrollado por Apple para el desarrollo de aplicaciones en sus plataformas, como iOS, macOS, watchOS y tvOS. A continuación, se presentan las pautas que debemos seguir al utilizar Swift en nuestro código:

1. [ ] **Espacios alrededor de operadores:** Es importante utilizar espacios alrededor de operadores matemáticos, 
   lógicos y de comparación para mejorar la legibilidad del código Swift.

    ```swift
    let x = 5
    if x > 0 && x < 10 {
        print("x está entre 0 y 10")
    }
    ```
   
    Este formato permite que el código se lea de forma fluida y se reduzcan los errores visuales.

2. [ ] **Finalización de sentencias simples:** En Swift, no es obligatorio usar punto y coma (;) al final de una 
   línea, y se debe evitar su uso salvo en casos muy específicos (como múltiples instrucciones en una sola línea, que también deben evitarse).
    
     ```swift
     let x = 5
     print("Hola, mundo")
     ```
    
     Este estilo de escritura ayuda a mantener el código limpio y fácil de seguir.

3. [ ] **Llaves en funciones y estructuras de control:** Las llaves deben abrirse al final de la línea de definición del 
   bloque (if, for, func, etc.) y cerrarse en una nueva línea. Es preferible no usar bloques de una sola línea sin llaves, aunque Swift lo permite.
    
     ```swift
     func miFuncion() {
          if x > 0 {
                print("x es positivo")
          }
     }
     ```
    
     Este formato mejora la claridad y la organización del código.

4. [ ] **Declaración de variables:** Usar let para variables inmutables (preferido) y var solo cuando se necesite 
   mutabilidad. Utilizar nombres descriptivos en camelCase.

    ```swift
    let nombre = "Juan"
    var edad = 25
    ```
    
    Este enfoque mejora la claridad del código y evita confusiones sobre la mutabilidad de las variables.

5. [ ] **Definición de clases y estructuras:** 
   Las clases deben declararse con class, seguidas por las propiedades en el constructor primario (si es necesario). 
   Los bloques deben estar correctamente tabulados y las propiedades deben seguir un orden lógico.

    ```swift
    class Persona {
        var nombre: String
        var edad: Int

        init(nombre: String, edad: Int) {
            self.nombre = nombre
            self.edad = edad
        }

        func saludar() {
            print("Hola, soy \(nombre) y tengo \(edad) años.")
        }
    }
    ```
    
    Este estilo de declaración ayuda a mantener un código limpio y fácil de entender.

6. [ ] **Funciones pequeñas y expresivas:** Cada función debe realizar una sola tarea y su nombre debe describir 
   claramente su propósito. Las funciones que retornan una sola expresión pueden usar la sintaxis de expresión.

    ```swift
    func sumar(a: Int, b: Int) -> Int {
        return a + b
    }

    func sumar(a: Int, b: Int) -> Int {
        a + b
    }
    ```
    
    Este estilo de escritura ayuda a mantener el código limpio y fácil de seguir.


7. [ ] **Uso de closures y funciones de orden superior:** Aprovechar la sintaxis funcional de Swift para colecciones y operaciones simples.
    
     ```swift
     let numeros = [1, 2, 3, 4, 5]
     let cuadrados = numeros.map { $0 * $0 }
     print(cuadrados) // [1, 4, 9, 16, 25]
     ```
     
     Este enfoque mejora la legibilidad y la expresividad del código.

8. [ ] **Manejo seguro de opcionales:** Evitar el uso de ! salvo cuando se tenga absoluta certeza. Usar if let, guard 
   let, o el operador de coalescencia ?? para trabajar con opcionales de forma segura.

    ```swift
    func obtenerNombre() -> String? {
        return nil
    }

    // Uso de if let
    if let nombre = obtenerNombre() {
        print(nombre)
    } else {
        print("Nombre no disponible")
    }

    // Uso de guard let
    func imprimirNombre() {
        guard let nombre = obtenerNombre() else {
            print("Nombre no disponible")
            return
        }
        print(nombre)
    }
    ```
   
    Este enfoque ayuda a prevenir errores de nil y mejora la seguridad del código.

9. [ ]  **Organización del archivo Swift:** El orden recomendado en un archivo es:

    * Importaciones
   * Comentarios de encabezado
   * Declaraciones de tipo (clases/structs)
   * Propiedades
   * Inicializadores
   * Métodos públicos
   * Métodos privados
   * Extensiones

     ```swift
     import UIKit

     /// Clase principal de la aplicación
     class MiAplicacion: UIViewController {
         // Propiedades
         var nombre: String

         // Inicializador
         init(nombre: String) {
             self.nombre = nombre
             super.init(nibName: nil, bundle: nil)
         }

         // Métodos públicos
         func saludar() {
             print("Hola, soy \(nombre)")
         }

         // Métodos privados
         private func metodoPrivado() {
             // Lógica privada
         }
     }
     ```

    Una organización clara mejora el mantenimiento del código y la colaboración.

10. [ ] **Comentarios y documentación:** Usar /// para documentar funciones, propiedades y clases. Utilizar // MARK: 
para 
    separar secciones de código dentro del archivo.

    ```swift
    /// Suma dos enteros y devuelve el resultado.
    /// - Parameters:
    ///   - a: El primer número.
    ///   - b: El segundo número.
    /// - Returns: El resultado de la suma.
    func sumar(_ a: Int, _ b: Int) -> Int {
    return a + b
    }
    
    // MARK: - Métodos Auxiliares
    
    func calcularPromedio(_ numeros: [Int]) -> Double {
        let suma = numeros.reduce(0, +)
        return Double(suma) / Double(numeros.count)
    }
    ```
    
    Esta práctica es esencial en proyectos colaborativos y de largo plazo.





### 6.1.4. Software Deployment Configuration

### Landing Page Deployment

Para desplegar la Landing Page desde GitHubPages hay que seguir los siguientes pasos:

**1. Ubicar el repositorio que tiene guardado el codigo fuente y dirigirse al apartado de configuración (settings):**


![repo-landing-page.png](../assets/img/chapter-VI/sprint-1/repo-landing-page.png)


**2. Seleccionar la sección pages:**


![pages-landing-page.png](../assets/img/chapter-VI/sprint-1/pages-landing-page.png)


**3. Configurar la rama que será usada para hacer deploy:**

![rama-landing-page.png](../assets/img/chapter-VI/sprint-1/rama-landing-page.png)

### Web services Deployment (API REST)

El despliegue de los servicios web se realizará en la nube utilizando el servicio de
GCP (Google Cloud platform). Para ello se utilizará el servicio de App Engine, que 
permite desplegar aplicaciones web y servicios en la nube de manera sencilla 
y escalable.






## 6.2. Landing Page & Mobile Application Implementation


### 6.2.1. Sprint 1


#### 6.2.1.1. Sprint Planning 1


#### 6.2.1.2. Sprint Backlog 1


#### 6.2.1.3. Development Evidence for Sprint Review

<table>
  <tr>
    <td align ="center" > <strong>Repository</strong></td>
    <td  align ="center" > <strong>Branch</strong></td>
    <td  align ="center" > <strong>Commit ID</strong></td>
    <td  align ="center" > <strong>Commit message</strong></td>
    <td  align ="center" > <strong>Commit Masagge body</strong></td>
    <td  align ="center" > <strong>Commit on (date)</strong></td>
  </tr>

  <tr>
    <td rowspan="16" align="center"> https://github.com/upc-2025-01-MetaSoft-App-Moviles/ElixirLine-Landing-Page.git </td>
    <td align="center"> Master </td>
    <td align="center"> b09ede62c8d4705d99faeb5abdd9e95ff47b86ce </td>
    <td align="center"> initial commit </td>
    <td align="center">  </td>
    <td align="center"> 2025/04/14 </td>
  </tr>

  <tr>
    <td align="center"> develop </td>
    <td align="center"> b09ede62c8d4705d99faeb5abdd9e95ff47b86ce </td>
    <td align="center"> chore: Added initial landing page project structure. </td>
    <td align="center">  </td>
    <td align="center"> 2025/04/14 </td>
  </tr>
  
  <tr>
    <td align="center"> feat/Benefits </td>
    <td align="center"> 05431e5c9484a19a83ff3e61fbcdb063a18c46c2 </td>
    <td align="center"> feat(benefits): benefits seccion added. </td>
    <td align="center">  </td>
    <td align="center"> 2025/05/08 </td>
  </tr>

  <tr>
    <td align="center"> feat/SuscriptionsAndVideo </td>
    <td align="center"> 5ec751d9fb45fa63c6dc90aa838f78a9c94208e0 </td>
    <td align="center"> feat(SubscriptionsAndVideo): added Subscriptions and Video section </td>
    <td align="center">  </td>
    <td align="center"> 2025/05/08 </td>
  </tr>

  <tr>
    <td align="center"> header-hero </td>
    <td align="center"> 1a8bc4e4f804d2b670bf9d3b57b3ed3cf35777f6 </td>
    <td align="center"> feat(index): added header area content </td>
    <td align="center">  </td>
    <td align="center"> 2025/05/07 </td>
  </tr>
</table>

#### 6.2.1.4. Testing Suite Evidence for Sprint Review

Para este primer sprint no se realizaron testing.

#### 6.2.1.5. Execution Evidence for Sprint Review

Tras finalizar el Sprint 1, conseguimos desarrollar por completo todas las secciones de nuestra Landing Page, asegurando una visualización óptima. Asimismo, aplicamos un diseño atractivo que capta la atención del usuario y lo dirige hacia los distintos elementos de la página. También incorporamos funcionalidades de navegación, como botones situados en la parte superior, que facilitan el desplazamiento entre las secciones.

Cabe resaltar que el propósito principal de esta Landing Page es convertir a los visitantes en clientes potenciales o usuarios recurrentes del servicio. Para ello, integramos llamados a la acción (Call To Action) que los conducen directamente a la aplicación web.

A continuación, compartimos capturas de pantalla que muestran el progreso alcanzado en el desarrollo de la Landing Page:

#### 6.2.1.6. Services Documentation Evidence for Sprint Review

Durante el primer Sprint, el equipo de desarrollo de MetaSoft diseñó, programó y habilitó el sitio web (Landing Page) destinado a presentar la aplicación web propuesta, llamada "ElixirLine". En esta Landing Page se pueden visualizar diversas secciones que explican en qué consiste "ElixirLine". Cada miembro del equipo de MetaSoft fue responsable del desarrollo de una sección específica.

<table>
  <thead>
    <tr>
      <th>End Point</th>
      <th> Funciones</th>
    </tr>
  </thead>
  <tbody>
    <tr>
        <td>AQUI SUBIR Landing DEPLOYADO</td>
        <td>Mostrar la Landing Page Desplegada</td>
    </tr>
  </tbody>
</table>

#### 6.2.1.7. Software Deployment Evidence for Sprint Review

Para llevar a cabo la implementación de nuestro sitio web, decidimos utilizar GitHub Pages. Durante este proceso, creamos un repositorio en GitHub que nos permitió gestionar el control de versiones. Desde la sección de Configuración, publicamos el proyecto alojado en la rama "¿?", el cual anteriormente se encontraba en la rama "¿?".

[Landing Page ElixirLine]() - FALTA LINK

#### 6.2.1.8. Team Collaboration Insights during Sprint


## 6.3. Validation Interviews


### 6.3.1. Diseño de Entrevistas


### 6.3.2. Registro de Entrevistas


### 6.3.3. Evaluaciones según heurísticas


## 6.4. Video About-the-Product


# Conclusiones y recomendaciones


# Video About-the-team


# Bibliografía


# Anexos